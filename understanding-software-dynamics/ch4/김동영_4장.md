# Understanding Software Dynamics Ch.04

## 책 내용 정리 (희망하는 사람만)

1024 x 1024 행렬 곱셉
```c
for(int row = 0; row < 1024; ++row){
    for(int col = 0; col < 1024; ++col){
        double sum = 0.0;
        for(int k = 0; k < 1024; ++k){
            sum += a[row, k] * b[k, col];
        }
        c[row, col] = sum;
    }
}
```

배열 a는 한 행에서 요소를 참조한다. 반면 배열 b는 열을 기준으로 이동하기에 서로 다른 캐시라인에 위치. 따라서 배열 b를 참조할 때는 캐시 미스 발생. 성능 저하를 의미한다. 

예상 시간 
곱셉 1024^3. 덧셈 1024^3. 3.GHZ 기준 2초 

### 관찰 
컴퓨터 과학 표준 초기화 값 0, 1 그리고 랜덤 값 사용한다. 그러나 0과 1의 값은 CPU에서 사용가능한 계산을 단축하는 경향이 있으므로 대신 1에 가까운 값을 사용한다.

초기 결과
6.5s

행 -> 열 계산에서 열 -> 행 계산으로 변환한 결과 20% 캐시 미스 증가. 그러나 속도 향상. 6.5s에서 5.1s 

L3 상위 주소 비트 해시를 이용한 색인
열을 모든 L3 캐시 세트로 분산하는 효과를 낸다. 캐시 세트를 선택할 때 상위 비트에 XOR 수행. L3 캐시 미스 속도 4배 감소.

더 빠른 행렬 계산
1. 배열 b를 전치하는 것
2. 세 행렬을 재배열하는 것

배열 b를 전치하는 것
배열 bb라는 행 순서대로 접근하는 캐시 패턴 사용. 배열 bb를 만들기위해 128K의 캐시미스와 1M 캐시 미스 발생. 그러나 1번 수행으로 10억번 캐시 미스보다 1000배 성능 개선. 5.1 to 1.1s

세 행렬을 재배열하는 것
행x열로 이루어진 블록을 가져와 행 우선 순위로 읽어서 새 배열을 생성하고 기록한다. 이러한 방식을 행열 a, b에 수행하여 행열 aa, bb를 만든다. 곱셉한 결과 행열 cc로 만들어 거꾸로 매핑해 행열 c를 만듬으로서 0.3s의 성능 개선.
> 이해가 잘 안간다. 

## 좋았던 부분
단순하게 구현된임에도 불과하고 2차원 행열 배열에서 캐시를 적극 활용하여 성능 개선을 할수 있음을 깨달았다. 구현에서 캐시가 어떻게 동작하는지 추정 시간을 예측하고, 예측한 값과 결과값이 얼마나 차이가 나는지 이를 측정하여, 원인을 분석함으로서 성능을 개선할수 있다.