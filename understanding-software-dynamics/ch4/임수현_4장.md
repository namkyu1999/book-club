# Understanding Software Dynamics Ch.04

## 책 내용 정리 
많은 양의 데이터를 처리할 때 캐시를 잘 사용하는 조직은 그렇지 않은 조직에 비해 성능을 비약적으로 향상할 수 있다. 동시에 함께 접근되는 데이터는 메모리에 함께 보관하는 것도 도움이 된다.  
이것은 행렬뿐만 아니라 해시 테이블, 비-트리(B-tree), 연결 리스트 노드(Linked-list nodes), 네트워크 메시지와 수많은 자료구조에도 적용된다. 

## 새로 배운 내용

<details>
<summary>배정밀도</summary><hr>

단정밀도(single precision)는 `32비트` 를 사용하는 것을 이야기하며, 배정밀도(double precision)는 `64비트`를 사용하는 것을 이야기한다.

https://hellvelopment.tistory.com/66

</details>



<details>
<summary>memory access pattern</summary><hr>

<img width="554" alt="스크린샷 2024-08-12 오후 6 00 53" src="https://github.com/user-attachments/assets/de01ed47-4587-457d-91a8-d8c4be4e6bd7">

<img width="583" alt="스크린샷 2024-08-12 오후 6 01 41" src="https://github.com/user-attachments/assets/01d847c8-bef0-4f6c-b1f3-6ac70effd958">

<img width="581" alt="스크린샷 2024-08-12 오후 6 01 56" src="https://github.com/user-attachments/assets/9eabdb89-8b34-454b-a5fb-2282b9489237">

<img width="582" alt="스크린샷 2024-08-12 오후 6 02 09" src="https://github.com/user-attachments/assets/3b9509bf-de51-4983-920b-b32d5ad4b4c7">


https://youtu.be/ualcIR5pmsg?si=GrdsEzLYgsemaLUM 

</details>

<details>
<summary>p113 예시 설명</summary><hr>

> 예를 들어 8바이트 포인터와 8바이트 데이터가 있는 노드로 구성된 16바이트 연결 리스트 대신 하나의 포인터와 4개 이상의 데이터가 들어있는 64바이트의 노드로 구성된 연결 리스트를 사용하면 캐시 성능을 4배나 향상할 수 있다.


기존 연결 리스트 구조에서 각 노드는 8바이트의 포인터(다음 노드를 가리키는 포인터)와 8바이트의 데이터로 구성되어 있다. 따라서 한 노드의 크기는 16바이트이며 해당 16바이트 노드를 사용할 경우, 캐시는 연속적인 데이터를 가져오지 못하므로 노드를 따라가면서 메모리 접근을 여러 번 해야 한다.

반면, 각 노드가 64바이트의 크기를 가지며, 한 개의 포인터와 4개 이상의 데이터로 구성되도록 변경된 연결 리스트 구조는 더 많은 데이터를 하나의 노드에 포함시킨다. 따라서 64바이트 노드를 사용하면 캐시는 연속된 데이터(하나의 큰 노드)를 한 번에 가져올 수 있어, 메모리 접근 횟수가 줄어들고 속도가 빨라진다.

즉, 64바이트 노드는 16바이트 노드의 4배 크기이므로, 캐시 블록 하나에 4개의 16바이트 노드에 해당하는 데이터를 한 번에 담을 수 있다. 따라서 이론적으로 캐시 효율이 4배까지 개선될 수 있다.

</details>




